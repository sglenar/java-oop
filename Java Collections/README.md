# Collections

### Домашнее задание

В следующих заданиях необходимо реализовать методы, которые отвечают поставленной задаче. Это задание должно быть
выполнено без Stream API и других фич Java 8.

##### List

1. Сгенерируйте список из целых чисел от 1 до Х включительно.
1. Найдите минимальный элемент в коллекции `LocalDate`.
1. Создайте новый список, используя только элементы, стоящие на нечетных позициях оригинального списка (индексы с 0).
1. Создайте новый список из списка строк, используя только строки в виде целых чисел.
1. Проверьте, что в списке чисел нет отрицательных значений.
1. Отсортируйте список строк по длине по убыванию.
1. Проверьте что список строк отсортирован по алфавиту игнорируя регистр символов.
1. В строке, состоящей из символов `(`, `)`, `[`, `]`, `{`, `}`, проверьте правильность расстановки скобок,
   вернуть `true` или `false`. Символы должны идти парами, пары могут быть вложены друг в друга, но не должны
   пересекаться. Пример правильного выражения: `({}[]([]){{}[]})`

##### Set и Map

1. Удалите дубликаты из коллекции.
1. Сгенерируйте заданное число случайных и уникальных `LocalDate` в заданном году, отсортируйте хронологически.
1. Создайте новый Map из значений, передаваемых в vararg (ключ, значение, ключ, значение, ...). Если количество
   аргументов нечетное, выбросить исключение IllegalArgumentException с описанием проблемы и количеством аргументов.
1. Сгенерируйте `Map<Month, Integer>`, в которой ключами будут элементы перечисления `java.time.Month`, а значениями —
   длина названия этого месяца. То есть результат должен быть такой:
   `{MAY=3, SEPTEMBER=9, JUNE=4, APRIL=5, AUGUST=6, ...`
1. Подсчитайте количество дубликатов каждого элемента в списке. Метод должен возвращать `Map<K, Integer>`, где K —
   элемент из списка, а Integer — количество его вхождений в исходный список. Элементы, которые встречаются только 1
   раз, не должны входить в результат.
1. Трансформируйте `List<Map<String, String>>` в список всех значений, которые используются в этих Map, сортировать по
   длине, затем по алфавиту.

##### Собственная реализация

Создать класс DynamicArray, являющийся собственной реализацией динамического контейнера. Класс должен содержать внутри
себя массив generic-элементов. Должны быть реализованы конструкторы для создания такого контейнера без каких-либо
параметров (длина по умолчанию 10), с начальной длиной или с начальным массивом значений vararg. Класс должен
поддерживать следующие методы:

- `addElement` - добавление элемента в конец массива
- `addElement` - добавление элемента по произвольному индексу
- `setElement` - перезапись элемента по индексу
- `getElement` - получение элемента по индексу
- `removeElement` удаление произвольного элемента по индексу `removeElement`
- `containsElement` - проверка на вхождение элемента
- `getSize` - получение текущего размера
- `toString` - конвертация внутреннего состояния для печати в виде `[1, 2, 3]`.
- `equals` и `hashCode` - сравнение с другими объектами

При заполнении внутреннего массива он должен пересоздаваться. В случаях, если операции невозможно совершить, класс
должен выбрасывать `IllegalArgumentException`.

Также можно предоставить код, демонстрирующий эти методы.

### Критерии оценки

- Пройдены все юнит-тесты упражнений List - 1 балл
- Пройдены все юнит-тесты упражнений Map - 1 балл
- Пройдены все юнит-тесты для DynamicArray - 1 балл
- Пройден статический анализ - 0.5 балла
- Код легко читаемый, методы и переменные названы понятными смысловыми именами - 0.5 балла
- Код DynamicArray логично разделен на методы, предусмотрено несколько видов ошибок - 1 балл.